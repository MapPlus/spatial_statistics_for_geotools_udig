/*
 *    GeoTools - The Open Source Java GIS Toolkit
 *    http://geotools.org
 *
 *    (C) 2014, Open Source Geospatial Foundation (OSGeo)
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation;
 *    version 2.1 of the License.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 */
package org.geotools.process.spatialstatistics.operations;

import java.awt.Font;
import java.awt.Shape;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.geometry.DirectPosition2D;
import org.geotools.geometry.jts.JTS;
import org.geotools.process.spatialstatistics.core.FeatureTypes;
import org.geotools.process.spatialstatistics.storage.IFeatureInserter;
import org.geotools.process.spatialstatistics.util.MaximumInscribedRectangle;
import org.geotools.referencing.operation.DefaultMathTransformFactory;
import org.geotools.referencing.operation.matrix.GeneralMatrix;
import org.geotools.util.logging.Logging;
import org.locationtech.jts.algorithm.Angle;
import org.locationtech.jts.algorithm.MinimumDiameter;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.CoordinateSequence;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.LinearRing;
import org.locationtech.jts.geom.MultiPolygon;
import org.locationtech.jts.geom.Point;
import org.locationtech.jts.geom.Polygon;
import org.locationtech.jts.geom.TopologyException;
import org.locationtech.jts.geom.impl.CoordinateArraySequence;
import org.locationtech.jts.geom.util.AffineTransformation;
import org.locationtech.jts.index.strtree.STRtree;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.geometry.DirectPosition;
import org.opengis.geometry.MismatchedDimensionException;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.MathTransformFactory;
import org.opengis.referencing.operation.TransformException;

/**
 * Creates a features containing lines generated by converting polygon boundaries to lines, or splitting line, polygon, or both features at their
 * intersections.
 * 
 * @author jyajya, OnSpatial
 * 
 * @source $URL$
 * 
 */
public class LabelToGeometryOperation extends GeneralOperation {
    protected static final Logger LOGGER = Logging.getLogger(LabelToGeometryOperation.class);

    private STRtree spatialIndex;

    private String attName = null;

    private String fontName = null;

    private Integer fontType = null;

    public LabelToGeometryOperation() {

    }

    public SimpleFeatureCollection execute(SimpleFeatureCollection inputFeatures,
            String labelAttributeName, String fontName, Integer fontType) throws IOException {
        this.attName = labelAttributeName;
        this.fontName = fontName;
        this.fontType = fontType;

        SimpleFeatureType schema = inputFeatures.getSchema();
        // SimpleFeatureType featureType = FeatureTypes.build(schema, LineString.class);
        // CoordinateReferenceSystem crs = schema.getCoordinateReferenceSystem();
        CoordinateReferenceSystem objCRS = schema.getCoordinateReferenceSystem();
        IFeatureInserter featureWriter = getFeatureWriter(schema);
        featureWriter.setFlushInterval(500);
        SimpleFeatureIterator sfi = inputFeatures.features();
        try {

            int maxValue = 30;
            int minValue = 2;
            Boolean forceDraw = true;
            Boolean representative = true;
            // int fontSize = 10;

            // if (inputFeatures == null) {
            // throw new NullPointerException("inputFeatures parameter required");
            // }

            GeometryFactory gf = new GeometryFactory();

            AffineTransform fontAT = new AffineTransform();
            fontAT.scale(1, 1);
            FontRenderContext context = new FontRenderContext(fontAT, false, false);

            String attVal = "";
            int cnt = 0;
            while (sfi.hasNext()) {
                Geometry rtGeom = null;
                SimpleFeature sf = sfi.next();
                Geometry geometry = (Geometry) sf.getDefaultGeometry();

                attVal = (String) sf.getAttribute(attName);

                Geometry modifiedGeom = MinimumDiameter.getMinimumRectangle(geometry);
                double[] distSet = getCmpDistance(modifiedGeom);
                double minWidth = distSet[0];
                // double maxWidth = distSet[1];

                double a = getLabelRotation(modifiedGeom);

                int fontSize = maxValue;
                DirectPosition p = new DirectPosition2D(objCRS, geometry.getCentroid().getX(),
                        geometry.getCentroid().getY());
                if (representative) {
                    for (int i = 1; i <= 5; i++) {
                        modifiedGeom = geometry.buffer(-1 * (minWidth / (i * 3.)));
                        if (modifiedGeom.isEmpty()) {
                            modifiedGeom = geometry;
                        } else {
                            p = new DirectPosition2D(objCRS, modifiedGeom.getCentroid().getX(),
                                    modifiedGeom.getCentroid().getY());
                            a = getLabelRotation(modifiedGeom);
                            break;
                        }
                    }
                    
                    //if(modifiedGeom.getArea() < geometry.getArea() / 3.0) {
                    //    modifiedGeom = MaximumInscribedRectangle.getRectangle(geometry, false);
                    //}

                    if (modifiedGeom.isEmpty()) {
                        a = getLabelRotation(geometry);
                    } else if (modifiedGeom.getNumGeometries() > 1) {
                        Geometry maxGeom = modifiedGeom.getGeometryN(0);
                        for (int i = 0; i < modifiedGeom.getNumGeometries(); i++) {
                            if (maxGeom.getArea() <= modifiedGeom.getGeometryN(i).getArea()) {
                                maxGeom = modifiedGeom.getGeometryN(i);
                            }
                        }
                        p = new DirectPosition2D(objCRS, maxGeom.getCentroid().getX(),
                                maxGeom.getCentroid().getY());
                        a = getLabelRotation(maxGeom);
                        // modifiedGeom = maxGeom;
                    }
                }
                
                //MaximumInscribedRectangle.getRectangle(part, rotate)

                CoordinateArraySequence cas = new CoordinateArraySequence(
                        new Coordinate[] { new Coordinate(p.getOrdinate(0), p.getOrdinate(1)) });
                Point pp = new Point(cas, gf);
                try {
                    if (!geometry.intersects(pp)) {
                        p = new DirectPosition2D(objCRS, geometry.getInteriorPoint().getX(),
                                geometry.getInteriorPoint().getY());
                        cas = new CoordinateArraySequence(new Coordinate[] {
                                new Coordinate(p.getOrdinate(0), p.getOrdinate(1)) });
                        pp = new Point(cas, gf);
                    }
                } catch (TopologyException te) {
                    geometry = geometry.buffer(0);
                    if (!geometry.intersects(pp)) {
                        p = new DirectPosition2D(objCRS, geometry.getInteriorPoint().getX(),
                                geometry.getInteriorPoint().getY());
                        cas = new CoordinateArraySequence(new Coordinate[] {
                                new Coordinate(p.getOrdinate(0), p.getOrdinate(1)) });
                        pp = new Point(cas, gf);
                    }
                }

                try {
                    double[] box = new double[10];
                    int initMaxValue = maxValue;
                    for (; initMaxValue >= minValue; initMaxValue--) {
                        if (initMaxValue == 0) {
                            break;
                        }
                        box = new double[6];
                        fontSize = initMaxValue;
                        Font font = new Font(this.fontName, this.fontType, fontSize);
                        // attName = "§∫♨☎㈜";
                        TextLayout tl = new TextLayout(attVal, font, context);
                        Shape s = tl.getOutline(null);
                        PathIterator pIt = s.getPathIterator(fontAT);
                        List<Coordinate> csList = null;

                        List<Polygon> geoms = new ArrayList<>();
                        while (!pIt.isDone()) {
                            int segment = pIt.currentSegment(box);

                            if (segment == 4) {
                                csList.add(csList.get(0));
                                Coordinate[] cc = new Coordinate[csList.size()];
                                cc = csList.toArray(cc);
                                CoordinateArraySequence cas1 = new CoordinateArraySequence(cc);
                                LinearRing lr1 = new LinearRing(cas1, gf);
                                rtGeom = new Polygon(lr1, null, gf);

                                geoms.add((Polygon) rtGeom);
                            } else if (segment == 3) {
                                double[] xs = bezier(csList.get(csList.size() - 1).x, box[0],
                                        box[2], box[4], 10);
                                double[] ys = bezier(csList.get(csList.size() - 1).y, box[1],
                                        box[3], box[5], 10);

                                for (int i = 0; i < xs.length; i++) {
                                    Coordinate c = new Coordinate(xs[i], ys[i]);
                                    csList.add(c);
                                }
                            } else if (segment == 2) {
                                double[] xs = quadraticPoint(csList.get(csList.size() - 1).x,
                                        box[0], box[2], 10);
                                double[] ys = quadraticPoint(csList.get(csList.size() - 1).y,
                                        box[1], box[3], 10);
                                for (int i = 0; i < xs.length; i++) {
                                    Coordinate c = new Coordinate(xs[i], ys[i]);
                                    csList.add(c);
                                }
                            } else if (segment == 1) {
                                Coordinate c = new Coordinate(box[0], box[1]);
                                csList.add(c);
                            } else if (segment == 0) {
                                Coordinate c = new Coordinate(box[0], box[1]);
                                csList = new ArrayList<>();
                                csList.add(c);
                            }
                            pIt.next();
                        }

                        Map<LinearRing, List<LinearRing>> shellMap = new HashMap<>();
                        for (int i = 0; i < geoms.size(); i++) {
                            LinearRing lr = geoms.get(i).getExteriorRing();
                            if (!shellMap.containsKey(lr)) {
                                shellMap.put(lr, new ArrayList<>());
                            }
                        }
                        for (int i = 0; i < geoms.size(); i++) {
                            for (int j = 0; j < geoms.size(); j++) {
                                if (geoms.get(j) == geoms.get(i)) {
                                    continue;
                                }
                                if (geoms.get(i).contains(geoms.get(j))) {
                                    LinearRing iLR = geoms.get(i).getExteriorRing();
                                    LinearRing jLR = geoms.get(j).getExteriorRing();
                                    shellMap.remove(jLR);
                                    if (!shellMap.get(iLR).contains(jLR)) {
                                        shellMap.get(iLR).add(jLR);
                                    }
                                } else if (geoms.get(j).contains(geoms.get(i))) {
                                    LinearRing iLR = geoms.get(i).getExteriorRing();
                                    LinearRing jLR = geoms.get(j).getExteriorRing();
                                    shellMap.remove(iLR);
                                    if (!shellMap.get(jLR).contains(iLR)) {
                                        shellMap.get(jLR).add(iLR);
                                    }
                                }
                            }
                        }

                        geoms = new ArrayList<>();
                        Iterator<LinearRing> it = shellMap.keySet().iterator();
                        while (it.hasNext()) {
                            LinearRing er = it.next();
                            List<LinearRing> irs = shellMap.get(er);

                            LinearRing[] intriors = new LinearRing[irs.size()];
                            intriors = irs.toArray(intriors);

                            Polygon g = new Polygon(er, intriors, gf);
                            geoms.add(g);
                        }
                        Polygon[] polys = new Polygon[geoms.size()];
                        polys = geoms.toArray(polys);
                        MultiPolygon mp = new MultiPolygon(polys, gf);
                        double ew = mp.getEnvelopeInternal().getWidth() / 2.;
                        double eh = mp.getEnvelopeInternal().getHeight() / 2.;

                        // 스크린 좌표계의 중심으로 이동, 반전, 회전
                        AffineTransformation at = AffineTransformation
                                .translationInstance(-ew, eh * 8 / 10).reflect(1, -1)
                                .rotate(a - (1.57 + 3.14));
                        mp = (MultiPolygon) at.transform(mp);

                        //
                        // System.out.println(scaleDominator);
                        // at = AffineTransformation.scaleInstance(scaleDominator / mp.getEnvelopeInternal().getWidth(),
                        // scaleDominator / mp.getEnvelopeInternal().getWidth());
                        // mp = (MultiPolygon) at.transform(mp);

                        // 실세계 좌표위치로 이동
                        at = AffineTransformation.translationInstance(p.getOrdinate(0),
                                p.getOrdinate(1));
                        mp = (MultiPolygon) at.transform(mp);

                        if (maxValue == minValue) {
                            rtGeom = mp;
                            break;
                        }
                        try {
                            // while (!geometry.contains(mp)) {
                            // if(mp.getArea() < 9) {
                            // mp = null;
                            // break;
                            // }
                            // mp = (MultiPolygon) scaleGeometry(mp, 0.9);
                            // }
                            // rtGeom = mp;
                            if (geometry.contains(mp)) {
                                rtGeom = mp;
                                break;
                            } else {
                                rtGeom = mp;

                            }
                        } catch (TopologyException tpe) {
                            mp = (MultiPolygon) mp.buffer(0);
                            if (geometry.contains(mp)) {
                                rtGeom = mp;
                                break;
                            } else {
                                rtGeom = mp;

                            }
                        }

                    }
                    if (!forceDraw && (initMaxValue < minValue && minValue != 0)) {
                        initMaxValue = 0;
                        rtGeom = null;
                    } else if (forceDraw && (initMaxValue < minValue && minValue != 0)) {
                        try {
                            int scaleCnt = 0;
                            while(!geometry.contains(rtGeom) && scaleCnt < 50) {
                                rtGeom = scaleGeometry(rtGeom, 0.8);
                                scaleCnt ++;
                            }
                        } catch (TopologyException te) {

                        }
                    }

                    sf.setDefaultGeometry(rtGeom);
                    insertFeature(featureWriter, sf, rtGeom);
                    // featureWriter.
                    //System.out.println((++cnt) + " +++++++++++++++++");
                } catch (Exception e) {
                    e.printStackTrace();
                    return null;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            featureWriter.rollback(e);
        } finally {
            featureWriter.close(sfi);
        }

        return featureWriter.getFeatureCollection();
    }

    private void insertFeature(IFeatureInserter featureWriter, SimpleFeature source,
            Geometry newGeometry) throws IOException {
        // SimpleFeature newFeature = featureWriter.buildFeature();
        source.setDefaultGeometry(newGeometry);
        featureWriter.write(source);
    }

    static final class NearFeature {

        public LineString location;

        public Object id;

        public NearFeature(LineString location, Object id) {
            this.location = location;
            this.id = id;
        }
    }

    private double[] getCmpDistance(Geometry modifiedGeom) {
        Coordinate[] coords = modifiedGeom.getCoordinates();
        Coordinate start = null;

        start = coords[0];
        double dist1 = start.distance(coords[1]);
        start = coords[1];
        double dist2 = start.distance(coords[2]);

        return new double[] { dist1, dist2 };
    }

    private double getLabelRotation(Geometry modifiedGeom) {
        Geometry g = MinimumDiameter.getMinimumRectangle(modifiedGeom);
        if (!(g instanceof Polygon)) {
            g = modifiedGeom;
        }
        double[] distSet = getCmpDistance(g);
        double dist1 = distSet[0];
        double dist2 = distSet[1];
        Coordinate start = null;
        Coordinate end = null;
        Coordinate[] coords = g.getCoordinates();
        if (dist1 > dist2) {
            start = coords[0];
            end = coords[1];
        } else {
            start = coords[1];
            end = coords[2];
        }

        double a = 0;
        if (end.x - start.x < 0) {
            a = Angle.angle(end, start);
        } else {
            a = Angle.angle(start, end);
        }

        return a;
    }

    private double[] bezier(Double p0, Double c1, Double c2, double p1, int pointCount) {
        double quality = pointCount;
        double[] rt = new double[pointCount];
        double t = 1. / quality;
        rt[0] = p0;
        for (int k = 1; k < quality; k++) {
            t += 1. / quality;
            double p = p0 * (1.0 - t) * (1.0 - t) * (1.0 - t) + c1 * 3.0 * t * (1.0 - t) * (1.0 - t)
                    + c2 * 3.0 * t * t * (1.0 - t) + p1 * t * t * t;
            rt[k] = p;
        }

        return rt;
    }

    private double[] quadraticPoint(double p0, double c1, double p1, int pointCount) {
        double quality = pointCount;
        double[] rt = new double[pointCount];
        double t = 1. / quality;
        rt[0] = p0;
        for (int k = 1; k < quality; k++) {
            t += 1. / quality;
            double x = (1 - t) * ((1 - t) * p0 + t * c1) + t * ((1 - t) * c1 + t * p1);
            rt[k] = x;
        }
        return rt;
    }

    public Geometry scaleGeometry(Geometry geometry, double scale) throws Exception {
        AffineTransform affineTransform = new AffineTransform();

        Point centroid = MinimumDiameter.getMinimumRectangle(geometry).getCentroid();

        affineTransform.translate(centroid.getX(), centroid.getY()); // 중심점으로 이동
        affineTransform.scale(scale, scale); // 축소
        affineTransform.translate(-centroid.getX(), -centroid.getY()); // 중심점으로 되돌리기

        MathTransformFactory mathTransformFactory = new DefaultMathTransformFactory();
        MathTransform transform = mathTransformFactory
                .createAffineTransform(new GeneralMatrix(affineTransform));

        Geometry scaledGeometry;
        try {
            scaledGeometry = JTS.transform(geometry, transform);
            // centroid = MinimumDiameter.getMinimumRectangle(scaledGeometry).getCentroid();
            // System.out.println(scaledGeometry.getArea());
        } catch (MismatchedDimensionException | TransformException e) {
            e.printStackTrace();
            return null;
        }

        return scaledGeometry;
    }
}